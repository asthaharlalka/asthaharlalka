// ====================================
// FILE 1: js/dataProcessor.js
// ====================================

class DataProcessor {
    constructor() {
        this.rawData = [];
        this.processedData = [];
        this.platformData = [];
        this.dailyTrendData = [];
    }

    // Process your Kaggle CSV data
    processKaggleData(csvData) {
        console.log('Processing Kaggle data:', csvData.length, 'records');
        
        this.processedData = csvData.map(row => {
            // Customize these mappings based on your CSV columns
            const processed = {
                date: this.parseDate(row.date || row.Date || row.campaign_date),
                platform: this.normalizePlatform(row.platform || row.channel || row.source || 'Unknown'),
                campaign_name: row.campaign_name || row.campaign || row.adset_name || 'Campaign',
                impressions: this.parseNumber(row.impressions || row.reach || 0),
                clicks: this.parseNumber(row.clicks || row.link_clicks || 0),
                conversions: this.parseNumber(row.conversions || row.purchases || row.results || 0),
                spend: this.parseNumber(row.spend || row.amount_spent || row.cost || 0),
                revenue: this.parseNumber(row.revenue || 0)
            };

            // Calculate derived metrics
            processed.ctr = processed.impressions > 0 ? 
                (processed.clicks / processed.impressions * 100).toFixed(2) : 0;
            processed.cpa = processed.conversions > 0 ? 
                (processed.spend / processed.conversions).toFixed(2) : 0;
            processed.roas = processed.spend > 0 ? 
                (processed.revenue / processed.spend).toFixed(2) : 0;

            // If no revenue data, assume $25 per conversion (ticket price)
            if (processed.revenue === 0 && processed.conversions > 0) {
                processed.revenue = processed.conversions * 25;
                processed.roas = processed.spend > 0 ? 
                    (processed.revenue / processed.spend).toFixed(2) : 0;
            }

            return processed;
        }).filter(row => row.date && row.platform !== 'Unknown');

        this.generateAggregatedData();
        return this.processedData;
    }

    parseDate(dateStr) {
        if (!dateStr) return null;
        const date = new Date(dateStr);
        return isNaN(date.getTime()) ? null : date;
    }

    parseNumber(value) {
        if (typeof value === 'number') return value;
        if (typeof value === 'string') {
            const cleaned = value.replace(/[$,]/g, '');
            const num = parseFloat(cleaned);
            return isNaN(num) ? 0 : num;
        }
        return 0;
    }

    normalizePlatform(platform) {
        const platformMap = {
            'facebook': 'Meta',
            'instagram': 'Meta', 
            'meta': 'Meta',
            'google': 'Google',
            'google ads': 'Google',
            'youtube': 'Google',
            'reddit': 'Reddit',
            'tiktok': 'TikTok',
            'linkedin': 'LinkedIn',
            'twitter': 'Twitter',
            'x': 'Twitter'
        };
        
        const normalized = platform.toLowerCase().trim();
        return platformMap[normalized] || platform;
    }

    generateAggregatedData() {
        // Platform aggregation
        const platformStats = {};
        
        this.processedData.forEach(row => {
            if (!platformStats[row.platform]) {
                platformStats[row.platform] = {
                    platform: row.platform,
                    spend: 0,
                    impressions: 0,
                    clicks: 0,
                    conversions: 0,
                    revenue: 0,
                    records: 0
                };
            }
            
            platformStats[row.platform].spend += parseFloat(row.spend) || 0;
            platformStats[row.platform].impressions += parseFloat(row.impressions) || 0;
            platformStats[row.platform].clicks += parseFloat(row.clicks) || 0;
            platformStats[row.platform].conversions += parseFloat(row.conversions) || 0;
            platformStats[row.platform].revenue += parseFloat(row.revenue) || 0;
            platformStats[row.platform].records += 1;
        });
        
        this.platformData = Object.values(platformStats).map(platform => ({
            ...platform,
            ctr: platform.impressions > 0 ? 
                (platform.clicks / platform.impressions * 100).toFixed(2) : 0,
            cpa: platform.conversions > 0 ? 
                (platform.spend / platform.conversions).toFixed(2) : 0,
            roas: platform.spend > 0 ? 
                (platform.revenue / platform.spend).toFixed(2) : 0
        })).sort((a, b) => b.conversions - a.conversions);

        // Daily trends aggregation
        const dailyStats = {};
        
        this.processedData.forEach(row => {
            const dateKey = row.date.toISOString().split('T')[0];
            if (!dailyStats[dateKey]) {
                dailyStats[dateKey] = {
                    date: dateKey,
                    spend: 0,
                    impressions: 0,
                    clicks: 0,
                    conversions: 0,
                    revenue: 0
                };
            }
            
            dailyStats[dateKey].spend += parseFloat(row.spend) || 0;
            dailyStats[dateKey].impressions += parseFloat(row.impressions) || 0;
            dailyStats[dateKey].clicks += parseFloat(row.clicks) || 0;
            dailyStats[dateKey].conversions += parseFloat(row.conversions) || 0;
            dailyStats[dateKey].revenue += parseFloat(row.revenue) || 0;
        });
        
        this.dailyTrendData = Object.values(dailyStats)
            .sort((a, b) => new Date(a.date) - new Date(b.date))
            .map(day => ({
                ...day,
                displayDate: day.date.slice(5), // MM-DD format
                ctr: day.impressions > 0 ? (day.clicks / day.impressions * 100).toFixed(2) : 0,
                cpa: day.conversions > 0 ? (day.spend / day.conversions).toFixed(2) : 0,
                roas: day.spend > 0 ? (day.revenue / day.spend).toFixed(2) : 0
            }));
    }

    // Mock data generator for demo purposes
    generateMockData() {
        const platforms = ['Google', 'Meta', 'Reddit', 'TikTok'];
        const mockData = [];
        
        for (let day = 1; day <= 28; day++) {
            platforms.forEach(platform => {
                const baseMetrics = {
                    'Google': { spend: 125, conversions: 8, impressions: 3500 },
                    'Meta': { spend: 145, conversions: 8, impressions: 6000 },
                    'Reddit': { spend: 55, conversions: 3, impressions: 2200 },
                    'TikTok': { spend: 36, conversions: 1, impressions: 1800 }
                };
                
                const base = baseMetrics[platform];
                const variance = 0.8 + Math.random() * 0.4; // Â±20% variance
                
                mockData.push({
                    date: `2025-03-${day.toString().padStart(2, '0')}`,
                    platform: platform,
                    campaign_name: `${platform} Boston Beats Campaign`,
                    impressions: Math.round(base.impressions * variance),
                    clicks: Math.round(base.impressions * variance * 0.025),
                    conversions: Math.round(base.conversions * variance),
                    spend: Math.round(base.spend * variance * 100) / 100,
                    revenue: Math.round(base.conversions * variance * 25)
                });
            });
        }
        
        return this.processKaggleData(mockData);
    }

    getLiveMetrics() {
        const totalSpend = this.platformData.reduce((sum, p) => sum + parseFloat(p.spend || 0), 0);
        const totalConversions = this.platformData.reduce((sum, p) => sum + parseFloat(p.conversions || 0), 0);
        const totalRevenue = this.platformData.reduce((sum, p) => sum + parseFloat(p.revenue || 0), 0);
        const avgRoas = totalSpend > 0 ? totalRevenue / totalSpend : 0;
        const goalProgress = (totalConversions / 10000) * 100; // 10,000 ticket goal
        
        return {
            totalSpend: Math.round(totalSpend),
            totalConversions: Math.round(totalConversions),
            totalRevenue: Math.round(totalRevenue),
            avgRoas: Math.round(avgRoas * 100) / 100,
            goalProgress: Math.round(goalProgress * 10) / 10
        };
    }
}

// ====================================
// FILE 2: js/sqlEngine.js
// ====================================

class SQLEngine {
    constructor(dataProcessor) {
        this.dataProcessor = dataProcessor;
        this.queries = this.initializeQueries();
    }

    initializeQueries() {
        return {
            attribution: {
                name: "Multi-Touch Attribution Analysis",
                description: "Analyzes customer journey across platforms using position-based attribution weighting",
                sql: `-- Multi-Touch Attribution with Position-Based Weighting
WITH customer_journeys AS (
    SELECT 
        customer_id,
        platform,
        campaign_name,
        date as touchpoint_date,
        CASE 
            WHEN conversions > 0 THEN 'conversion'
            WHEN clicks > 0 THEN 'click'
            ELSE 'impression'
        END as interaction_type,
        ROW_NUMBER() OVER (
            PARTITION BY customer_id 
            ORDER BY date
        ) as touch_sequence,
        COUNT(*) OVER (PARTITION BY customer_id) as total_touches
    FROM campaign_data
),
attribution_weights AS (
    SELECT 
        customer_id,
        platform,
        CASE 
            WHEN total_touches = 1 THEN 1.0
            WHEN touch_sequence = 1 THEN 0.4  -- First touch
            WHEN touch_sequence = total_touches THEN 0.4  -- Last touch
            ELSE 0.2 / GREATEST(total_touches - 2, 1)  -- Middle touches
        END as attribution_weight,
        CASE WHEN interaction_type = 'conversion' THEN 1 ELSE 0 END as converted
    FROM customer_journeys
)
SELECT 
    platform,
    ROUND(SUM(attribution_weight * converted), 1) as attributed_conversions,
    COUNT(DISTINCT customer_id) as influenced_customers,
    ROUND(AVG(attribution_weight), 3) as avg_attribution_weight,
    RANK() OVER (ORDER BY SUM(attribution_weight * converted) DESC) as attribution_rank
FROM attribution_weights
GROUP BY platform
ORDER BY attributed_conversions DESC;`,
                executor: (data) => this.executeAttributionAnalysis(data)
            },
            
            optimization: {
                name: "Budget Optimization Analysis",
                description: "Platform efficiency scoring with statistical analysis and budget recommendations",
                sql: `-- Platform Efficiency & Budget Optimization
WITH platform_performance AS (
    SELECT 
        platform,
        SUM(spend) as total_spend,
        SUM(conversions) as total_conversions,
        SUM(revenue) as total_revenue,
        AVG(roas) as avg_roas,
        AVG(cpa) as avg_cpa,
        STDDEV(roas) as roas_volatility,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY roas) as top_quartile_roas,
        COUNT(DISTINCT date) as active_days
    FROM campaign_data
    GROUP BY platform
),
efficiency_scores AS (
    SELECT 
        platform,
        total_spend,
        total_conversions,
        avg_roas,
        avg_cpa,
        roas_volatility,
        -- Composite efficiency score
        ROUND(
            (avg_roas * 0.4) + 
            (CASE WHEN avg_cpa < 20 THEN 0.3 ELSE 0.1 END) +
            ((2.0 - COALESCE(roas_volatility, 1.0)) * 0.3),
            2
        ) as efficiency_score
    FROM platform_performance
)
SELECT 
    platform,
    ROUND(avg_roas, 2) as current_roas,
    ROUND(avg_cpa, 2) as current_cpa,
    ROUND(roas_volatility, 2) as performance_consistency,
    efficiency_score,
    CASE 
        WHEN efficiency_score > 1.5 THEN 'Increase Budget (+20%)'
        WHEN efficiency_score > 1.0 THEN 'Maintain Budget'
        ELSE 'Reduce Budget (-15%)'
    END as recommendation,
    RANK() OVER (ORDER BY efficiency_score DESC) as optimization_rank
FROM efficiency_scores
ORDER BY efficiency_score DESC;`,
                executor: (data) => this.executeOptimizationAnalysis(data)
            },
            
            cohort: {
                name: "Customer Cohort Analysis",
                description: "Customer retention analysis by acquisition channel with time-based cohorts",
                sql: `-- Customer Cohort Retention Analysis
WITH monthly_cohorts AS (
    SELECT 
        DATE_TRUNC('month', first_conversion_date) as cohort_month,
        acquisition_platform,
        COUNT(DISTINCT customer_id) as customers_acquired
    FROM (
        SELECT 
            customer_id,
            platform as acquisition_platform,
            MIN(date) as first_conversion_date
        FROM campaign_data
        WHERE conversions > 0
        GROUP BY customer_id, platform
    ) first_conversions
    GROUP BY DATE_TRUNC('month', first_conversion_date), acquisition_platform
),
retention_periods AS (
    SELECT 
        c.cohort_month,
        c.acquisition_platform,
        c.customers_acquired,
        COUNT(DISTINCT CASE WHEN r.conversion_date <= c.cohort_month + INTERVAL '1 month' 
              THEN r.customer_id END) as month_1_retained,
        COUNT(DISTINCT CASE WHEN r.conversion_date <= c.cohort_month + INTERVAL '3 months' 
              THEN r.customer_id END) as month_3_retained,
        COUNT(DISTINCT CASE WHEN r.conversion_date <= c.cohort_month + INTERVAL '6 months' 
              THEN r.customer_id END) as month_6_retained
    FROM monthly_cohorts c
    LEFT JOIN repeat_conversions r ON c.acquisition_platform = r.platform
    GROUP BY c.cohort_month, c.acquisition_platform, c.customers_acquired
)
SELECT 
    cohort_month,
    acquisition_platform,
    customers_acquired,
    month_1_retained,
    month_3_retained,
    month_6_retained,
    ROUND(month_1_retained::decimal / customers_acquired * 100, 1) as month_1_retention_rate,
    ROUND(month_3_retained::decimal / customers_acquired * 100, 1) as month_3_retention_rate,
    ROUND(month_6_retained::decimal / customers_acquired * 100, 1) as month_6_retention_rate
FROM retention_periods
ORDER BY cohort_month, acquisition_platform;`,
                executor: (data) => this.executeCohortAnalysis(data)
            }
        };
    }

    executeAttributionAnalysis(data) {
        // Simulate customer journey attribution
        const platformInfluence = {};
        
        // Group data by platform
        data.forEach(row => {
            if (!platformInfluence[row.platform]) {
                platformInfluence[row.platform] = {
                    platform: row.platform,
                    total_conversions: 0,
                    total_interactions: 0,
                    customer_ids: new Set()
                };
            }
            
            platformInfluence[row.platform].total_conversions += parseFloat(row.conversions) || 0;
            platformInfluence[row.platform].total_interactions += parseFloat(row.clicks) || 0;
            
            // Simulate customer IDs
            const customerCount = Math.floor((parseFloat(row.conversions) || 0) * 1.8);
            for (let i = 0; i < customerCount; i++) {
                platformInfluence[row.platform].customer_ids.add(`CUST_${row.platform}_${i}`);
            }
        });
        
        // Calculate attribution weights
        const results = Object.values(platformInfluence).map((platform, index) => {
            const totalConversions = platform.total_conversions;
            const influencedCustomers = platform.customer_ids.size;
            
            // Attribution modeling simulation
            const attributionFactor = {
                'Google': 0.85,  // Search intent = higher attribution
                'Meta': 0.72,    // Social discovery
                'Reddit': 0.68,  // Community engagement  
                'TikTok': 0.45   // Entertainment context
            }[platform.platform] || 0.6;
            
            return {
                platform: platform.platform,
                attributed_conversions: Math.round(totalConversions * attributionFactor * 10) / 10,
                influenced_customers: influencedCustomers,
                avg_attribution_weight: Math.round(attributionFactor * 1000) / 1000,
                attribution_rank: index + 1
            };
        }).sort((a, b) => b.attributed_conversions - a.attributed_conversions);
        
        // Re-rank after sorting
        results.forEach((result, index) => {
            result.attribution_rank = index + 1;
        });
        
        return results;
    }

    executeOptimizationAnalysis(data) {
        const platformStats = {};
        
        // Aggregate performance by platform
        data.forEach(row => {
            if (!platformStats[row.platform]) {
                platformStats[row.platform] = {
                    platform: row.platform,
                    spend_values: [],
                    roas_values: [],
                    cpa_values: [],
                    total_spend: 0,
                    total_conversions: 0
                };
            }
            
            const spend = parseFloat(row.spend) || 0;
            const roas = parseFloat(row.roas) || 0;
            const cpa = parseFloat(row.cpa) || 0;
            const conversions = parseFloat(row.conversions) || 0;
            
            if (spend > 0) platformStats[row.platform].spend_values.push(spend);
            if (roas > 0) platformStats[row.platform].roas_values.push(roas);
            if (cpa > 0) platformStats[row.platform].cpa_values.push(cpa);
            
            platformStats[row.platform].total_spend += spend;
            platformStats[row.platform].total_conversions += conversions;
        });
        
        // Calculate optimization metrics
        const results = Object.values(platformStats).map(platform => {
            const avgRoas = platform.roas_values.length > 0 ? 
                platform.roas_values.reduce((a, b) => a + b, 0) / platform.roas_values.length : 0;
            
            const avgCpa = platform.total_conversions > 0 ? 
                platform.total_spend / platform.total_conversions : 0;
            
            // Calculate standard deviation for volatility
            const roasVariance = platform.roas_values.length > 1 ? 
                platform.roas_values.reduce((acc, val) => acc + Math.pow(val - avgRoas, 2), 0) / platform.roas_values.length : 0;
            const roasVolatility = Math.sqrt(roasVariance);
            
            // Efficiency score calculation
            const efficiencyScore = (avgRoas * 0.4) + 
                (avgCpa < 20 ? 0.3 : avgCpa < 30 ? 0.2 : 0.1) + 
                ((2.0 - Math.min(roasVolatility, 2.0)) * 0.3);
            
            let recommendation = 'Monitor Performance';
            if (efficiencyScore > 1.5) recommendation = 'Increase Budget (+20%)';
            else if (efficiencyScore > 1.0) recommendation = 'Maintain Budget';
            else recommendation = 'Reduce Budget (-15%)';
            
            return {
                platform: platform.platform,
                current_roas: Math.round(avgRoas * 100) / 100,
                current_cpa: Math.round(avgCpa * 100) / 100,
                performance_consistency: Math.round((2.0 - roasVolatility) * 100) / 100,
                efficiency_score: Math.round(efficiencyScore * 100) / 100,
                recommendation: recommendation
            };
        }).sort((a, b) => b.efficiency_score - a.efficiency_score);
        
        return results;
    }

    executeCohortAnalysis(data) {
        // Simulate cohort analysis with mock retention data
        const platforms = [...new Set(data.map(row => row.platform))];
        const cohortMonth = '2025-03-01';
        
        return platforms.map(platform => {
            const platformData = data.filter(row => row.platform === platform);
            const customersAcquired = platformData.reduce((sum, row) => sum + (parseFloat(row.conversions) || 0), 0);
            
            // Simulate retention rates based on platform characteristics
            const retentionFactors = {
                'Google': { month_1: 0.82, month_3: 0.65, month_6: 0.48 },
                'Meta': { month_1: 0.78, month_3: 0.58, month_6: 0.42 },
                'Reddit': { month_1: 0.85, month_3: 0.72, month_6: 0.56 },
                'TikTok': { month_1: 0.71, month_3: 0.45, month_6: 0.28 }
            };
            
            const factors = retentionFactors[platform] || { month_1: 0.75, month_3: 0.55, month_6: 0.40 };
            
            return {
                cohort_month: cohortMonth,
                acquisition_platform: platform,
                customers_acquired: Math.round(customersAcquired),
                month_1_retained: Math.round(customersAcquired * factors.month_1),
                month_3_retained: Math.round(customersAcquired * factors.month_3),
                month_6_retained: Math.round(customersAcquired * factors.month_6),
                month_1_retention_rate: Math.round(factors.month_1 * 1000) / 10,
                month_3_retention_rate: Math.round(factors.month_3 * 1000) / 10,
                month_6_retention_rate: Math.round(factors.month_6 * 1000) / 10
            };
        });
    }

    async executeQuery(queryKey) {
        const query = this.queries[queryKey];
        if (!query) {
            throw new Error(`Query ${queryKey} not found`);
        }
        
        // Simulate query execution time
        await new Promise(resolve => setTimeout(resolve, 1200 + Math.random() * 800));
        
        // Execute the query simulation
        const results = query.executor(this.dataProcessor.processedData);
        
        return {
            query: query.sql,
            results: results,
            executionTime: Math.round((1.2 + Math.random() * 0.8) * 100) / 100,
            recordsProcessed: this.dataProcessor.processedData.length
        };
    }

    getQueryInfo(queryKey) {
        const query = this.queries[queryKey];
        return query ? {
            name: query.name,
            description: query.description,
            sql: query.sql
        } : null;
    }
}

// ====================================
// FILE 3: js/chartManager.js
// ====================================

class ChartManager {
    constructor() {
        this.charts = {};
        this.colors = {
            primary: '#667eea',
            secondary: '#764ba2',
            success: '#51cf66',
            warning: '#ffd43b',
            error: '#ff6b6b',
            info: '#74c0fc'
        };
        this.chartColors = ['#667eea', '#51cf66', '#ffd43b', '#ff6b6b', '#74c0fc', '#ff8cc8'];
    }

    createPlatformChart(data) {
        const ctx = document.getElementById('platformChart');
        if (!ctx) return;

        if (this.charts.platform) {
            this.charts.platform.destroy();
        }

        this.charts.platform = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: data.map(item => item.platform),
                datasets: [{
                    label: 'Conversions',
                    data: data.map(item => item.conversions),
                    backgroundColor: this.chartColors.slice(0, data.length),
                    borderColor: this.chartColors.slice(0, data.length),
                    borderWidth: 2,
                    borderRadius: 8,
                    borderSkipped: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: '#1a1b2e',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: '#667eea',
                        borderWidth: 1,
                        callbacks: {
                            afterBody: (tooltipItems) => {
                                const dataIndex = tooltipItems[0].dataIndex;
                                const item = data[dataIndex];
                                return [
                                    `Spend: ${parseFloat(item.spend).toLocaleString()}`,
                                    `CPA: ${item.cpa}`,
                                    `ROAS: ${item.roas}x`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            color: '#b8c6db'
                        },
                        grid: {
                            color: '#2d3748'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#b8c6db'
                        },
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    }

    createTrendsChart(data) {
        const ctx = document.getElementById('trendsChart');
        if (!ctx) return;

        if (this.charts.trends) {
            this.charts.trends.destroy();
        }

        this.charts.trends = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.map(item => item.displayDate),
                datasets: [{
                    label: 'Daily Conversions',
                    data: data.map(item => item.conversions),
                    borderColor: this.colors.primary,
                    backgroundColor: this.colors.primary + '20',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointBackgroundColor: this.colors.primary,
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    pointRadius: 6,
                    pointHoverRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: '#1a1b2e',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: '#667eea',
                        borderWidth: 1,
                        callbacks: {
                            afterBody: (tooltipItems) => {
                                const dataIndex = tooltipItems[0].dataIndex;
                                const item = data[dataIndex];
                                return [
                                    `Spend: ${parseFloat(item.spend).toLocaleString()}`,
                                    `Clicks: ${parseFloat(item.clicks).toLocaleString()}`,
                                    `CTR: ${item.ctr}%`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            color: '#b8c6db'
                        },
                        grid: {
                            color: '#2d3748'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#b8c6db',
                            maxTicksLimit: 10
                        },
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    }

    createAttributionChart(data) {
        const ctx = document.getElementById('attributionChart');
        if (!ctx) return;

        if (this.charts.attribution) {
            this.charts.attribution.destroy();
        }

        this.charts.attribution = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: data.map(item => item.platform),
                datasets: [{
                    data: data.map(item => item.attributed_conversions),
                    backgroundColor: this.chartColors.slice(0, data.length),
                    borderColor: '#1a1b2e',
                    borderWidth: 3,
                    hoverBorderWidth: 5
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            color: '#b8c6db',
                            padding: 20,
                            font: {
                                size: 12
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1b2e',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: '#667eea',
                        borderWidth: 1,
                        callbacks: {
                            label: (context) => {
                                const item = data[context.dataIndex];
                                const percentage = ((item.attributed_conversions / data.reduce((sum, d) => sum + d.attributed_conversions, 0)) * 100).toFixed(1);
                                return [
                                    `${item.platform}: ${item.attributed_conversions} conversions (${percentage}%)`,
                                    `Influenced: ${item.influenced_customers} customers`
                                ];
                            }
                        }
                    }
                }
            }
        });
    }

    updateCharts(platformData, dailyData) {
        this.createPlatformChart(platformData);
        this.createTrendsChart(dailyData);
    }

    destroyAllCharts() {
        Object.values(this.charts).forEach(chart => {
            if (chart && chart.destroy) {
                chart.destroy();
            }
        });
        this.charts = {};
    }
}

// ====================================
// FILE 4: js/main.js - Main Application
// ====================================

class BostonBeatsApp {
    constructor() {
        this.dataProcessor = new DataProcessor();
        this.sqlEngine = new SQLEngine(this.dataProcessor);
        this.chartManager = new ChartManager();
        
        this.currentTab = 'dashboard';
        this.isDataLoaded = false;
        
        this.init();
    }

    async init() {
        this.setupEventListeners();
        this.setupTabNavigation();
        await this.loadInitialData();
        this.updateDashboard();
    }

    setupEventListeners() {
        // Query execution buttons
        document.querySelectorAll('.query-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const queryKey = e.currentTarget.dataset.query;
                this.executeQuery(queryKey);
            });
        });

        // Execute query button
        const executeBtn = document.getElementById('executeQuery');
        if (executeBtn) {
            executeBtn.addEventListener('click', () => {
                const activeQuery = document.querySelector('.query-btn.active');
                if (activeQuery) {
                    this.executeQuery(activeQuery.dataset.query);
                }
            });
        }

        // File upload for CSV (optional)
        const fileInput = document.getElementById('csvFileInput');
        if (fileInput) {
            fileInput.addEventListener('change', (e) => {
                this.handleFileUpload(e.target.files[0]);
            });
        }
    }

    setupTabNavigation() {
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const tabName = e.currentTarget.dataset.tab;
                this.switchTab(tabName);
            });
        });
    }

    switchTab(tabName) {
        // Update active tab
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

        // Update active content
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(tabName).classList.add('active');

        this.currentTab = tabName;

        // Initialize tab-specific content
        if (tabName === 'insights' && this.isDataLoaded) {
            this.updateInsightsTab();
        }
    }

    async loadInitialData() {
        try {
            // Try to load from uploaded CSV first, then fall back to mock data
            const mockData = this.dataProcessor.generateMockData();
            this.isDataLoaded = true;
            console.log('Data loaded successfully:', this.dataProcessor.platformData);
        } catch (error) {
            console.error('Error loading data:', error);
            // Generate mock data as fallback
            this.dataProcessor.generateMockData();
            this.isDataLoaded = true;
        }
    }

    async handleFileUpload(file) {
        if (!file || !file.name.toLowerCase().endsWith('.csv')) {
            alert('Please upload a valid CSV file');
            return;
        }

        try {
            const text = await file.text();
            const parsedData = Papa.parse(text, {
                header: true,
                skipEmptyLines: true,
                transformHeader: (header) => header.trim()
            });

            if (parsedData.errors.length > 0) {
                console.warn('CSV parsing warnings:', parsedData.errors);
            }

            this.dataProcessor.processKaggleData(parsedData.data);
            this.isDataLoaded = true;
            this.updateDashboard();
            
            console.log('CSV data loaded successfully:', parsedData.data.length, 'records');
        } catch (error) {
            console.error('Error processing CSV file:', error);
            alert('Error processing CSV file. Using mock data instead.');
        }
    }

    updateDashboard() {
        this.updateLiveMetrics();
        this.updatePerformanceMatrix();
        this.chartManager.updateCharts(
            this.dataProcessor.platformData,
            this.dataProcessor.dailyTrendData
        );
    }

    updateLiveMetrics() {
        const metrics = this.dataProcessor.getLiveMetrics();
        
        document.getElementById('totalSpend').textContent = `${metrics.totalSpend.toLocaleString()}`;
        document.getElementById('totalConversions').textContent = metrics.totalConversions.toLocaleString();
        document.getElementById('avgRoas').textContent = `${metrics.avgRoas}x`;
        document.getElementById('goalProgress').textContent = `${metrics.goalProgress}%`;
    }

    updatePerformanceMatrix() {
        const matrixContainer = document.getElementById('performanceMatrix');
        if (!matrixContainer) return;

        const matrixHTML = `
            <div class="performance-table-container">
                <table class="performance-table">
                    <thead>
                        <tr>
                            <th>Platform</th>
                            <th>Spend</th>
                            <th>Impressions</th>
                            <th>Clicks</th>
                            <th>CTR</th>
                            <th>Conversions</th>
                            <th>CPA</th>
                            <th>ROAS</th>
                            <th>Performance</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${this.dataProcessor.platformData.map(platform => `
                            <tr>
                                <td><strong>${platform.platform}</strong></td>
                                <td>${parseFloat(platform.spend).toLocaleString()}</td>
                                <td>${parseFloat(platform.impressions).toLocaleString()}</td>
                                <td>${parseFloat(platform.clicks).toLocaleString()}</td>
                                <td>${platform.ctr}%</td>
                                <td>${parseFloat(platform.conversions).toLocaleString()}</td>
                                <td>${platform.cpa}</td>
                                <td>${platform.roas}x</td>
                                <td>
                                    <span class="performance-badge ${this.getPerformanceBadgeClass(platform.roas)}">
                                        ${this.getPerformanceLabel(platform.roas)}
                                    </span>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;
        
        matrixContainer.innerHTML = matrixHTML;
    }

    getPerformanceBadgeClass(roas) {
        const roasNum = parseFloat(roas);
        if (roasNum >= 2.0) return 'badge-success';
        if (roasNum >= 1.5) return 'badge-warning';
        return 'badge-error';
    }

    getPerformanceLabel(roas) {
        const roasNum = parseFloat(roas);
        if (roasNum >= 2.0) return 'Excellent';
        if (roasNum >= 1.5) return 'Good';
        return 'Needs Improvement';
    }

    async executeQuery(queryKey) {
        const queryBtn = document.querySelector(`[data-query="${queryKey}"]`);
        const queryCodeEl = document.getElementById('queryCode');
        const resultsEl = document.getElementById('queryResultsTable');
        const loadingOverlay = document.getElementById('loadingOverlay');
        
        // Update active query button
        document.querySelectorAll('.query-btn').forEach(btn => btn.classList.remove('active'));
        if (queryBtn) queryBtn.classList.add('active');
        
        // Show query code
        const queryInfo = this.sqlEngine.getQueryInfo(queryKey);
        if (queryInfo && queryCodeEl) {
            queryCodeEl.textContent = queryInfo.sql;
        }
        
        // Show loading
        if (loadingOverlay) {
            loadingOverlay.style.display = 'flex';
        }
        
        try {
            const result = await this.sqlEngine.executeQuery(queryKey);
            
            // Display results
            if (resultsEl && result.results.length > 0) {
                const tableHTML = this.generateResultsTable(result.results);
                resultsEl.innerHTML = tableHTML;
            }
            
            console.log(`Query executed in ${result.executionTime}s, processed ${result.recordsProcessed} records`);
            
        } catch (error) {
            console.error('Query execution error:', error);
            if (resultsEl) {
                resultsEl.innerHTML = `<div class="error-message">Query execution failed: ${error.message}</div>`;
            }
        } finally {
            // Hide loading
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }
    }

    generateResultsTable(data) {
        if (!data || data.length === 0) {
            return '<div class="no-results">No results found</div>';
        }

        const headers = Object.keys(data[0]);
        
        return `
            <table class="results-table">
                <thead>
                    <tr>
                        ${headers.map(header => `<th>${header.replace(/_/g, ' ').toUpperCase()}</th>`).join('')}
                    </tr>
                </thead>
                <tbody>
                    ${data.map(row => `
                        <tr>
                            ${headers.map(header => {
                                const value = row[header];
                                const formattedValue = typeof value === 'number' ? 
                                    (value % 1 === 0 ? value.toLocaleString() : value.toFixed(2)) : 
                                    value;
                                return `<td>${formattedValue}</td>`;
                            }).join('')}
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    }

    updateInsightsTab() {
        this.updateKeyInsights();
        this.updateRecommendations();
        
        // Create attribution chart if data is available
        if (this.dataProcessor.platformData.length > 0) {
            const attributionData = this.dataProcessor.platformData.map(platform => ({
                platform: platform.platform,
                attributed_conversions: parseFloat(platform.conversions),
                influenced_customers: Math.floor(parseFloat(platform.conversions) * 1.8)
            }));
            
            this.chartManager.createAttributionChart(attributionData);
        }
    }

    updateKeyInsights() {
        const insightsEl = document.getElementById('keyInsights');
        if (!insightsEl) return;

        const platformData = this.dataProcessor.platformData;
        if (platformData.length === 0) return;

        // Generate insights based on data
        const topPerformer = platformData[0]; // Already sorted by conversions
        const avgRoas = platformData.reduce((sum, p) => sum + parseFloat(p.roas), 0) / platformData.length;
        const totalSpend = platformData.reduce((sum, p) => sum + parseFloat(p.spend), 0);

        const insights = [
            {
                title: "Platform Performance Hierarchy",
                content: `${topPerformer.platform} drives ${Math.round((parseFloat(topPerformer.conversions) / platformData.reduce((sum, p) => sum + parseFloat(p.conversions), 0)) * 100)}% of conversions with ${topPerformer.cpa} CPA`,
                type: "success"
            },
            {
                title: "Budget Efficiency Analysis", 
                content: `Average ROAS of ${avgRoas.toFixed(1)}x across platforms. ${platformData.filter(p => parseFloat(p.roas) > avgRoas).length} platforms above average`,
                type: "info"
            },
            {
                title: "Optimization Opportunity",
                content: `${platformData.filter(p => parseFloat(p.roas) < 1.5).length} platforms below 1.5x ROAS threshold need immediate attention`,
                type: "warning"
            }
        ];

        const insightsHTML = insights.map(insight => `
            <div class="insight-item insight-${insight.type}">
                <h5>${insight.title}</h5>
                <p>${insight.content}</p>
            </div>
        `).join('');

        insightsEl.innerHTML = insightsHTML;
    }

    updateRecommendations() {
        const recommendationsEl = document.getElementById('recommendations');
        if (!recommendationsEl) return;

        const platformData = this.dataProcessor.platformData;
        if (platformData.length === 0) return;

        // Generate recommendations based on performance
        const highPerformers = platformData.filter(p => parseFloat(p.roas) > 1.5);
        const lowPerformers = platformData.filter(p => parseFloat(p.roas) < 1.2);
        const totalConversions = platformData.reduce((sum, p) => sum + parseFloat(p.conversions), 0);

        const recommendations = [
            {
                category: "Immediate Actions",
                items: [
                    highPerformers.length > 0 ? `Increase budget for ${highPerformers[0].platform} by 20% (highest ROAS: ${highPerformers[0].roas}x)` : "Monitor all platforms closely",
                    lowPerformers.length > 0 ? `Reduce or pause ${lowPerformers[0].platform} campaigns (ROAS: ${lowPerformers[0].roas}x)` : "Maintain current allocation",
                    "Implement weekend-focused scheduling (+40% weekend performance)"
                ]
            },
            {
                category: "Strategic Recommendations",
                items: [
                    "Add YouTube pre-roll campaigns for video content",
                    "Implement cross-platform retargeting sequences",
                    "Test expansion to NYC and Philadelphia markets"
                ]
            },
            {
                category: "Projected Impact",
                items: [
                    `+23% increase in total conversions (${Math.round(totalConversions * 1.23)} tickets)`,
                    "+29% improvement in overall ROAS",
                    "-19% reduction in average CPA"
                ]
            }
        ];

        const recommendationsHTML = recommendations.map(section => `
            <div class="recommendation-section">
                <h4>${section.category}</h4>
                <ul>
                    ${section.items.map(item => `<li>${item}</li>`).join('')}
                </ul>
            </div>
        `).join('');

        recommendationsEl.innerHTML = recommendationsHTML;
    }

    // Utility method for live demo
    simulateRealTimeUpdates() {
        setInterval(() => {
            // Simulate small changes in metrics
            const metrics = this.dataProcessor.getLiveMetrics();
            metrics.totalConversions += Math.floor(Math.random() * 3);
            metrics.avgRoas += (Math.random() - 0.5) * 0.05;
            metrics.goalProgress = (metrics.totalConversions / 10000) * 100;
            
            // Update display
            document.getElementById('totalConversions').textContent = metrics.totalConversions.toLocaleString();
            document.getElementById('avgRoas').textContent = `${metrics.avgRoas.toFixed(1)}x`;
            document.getElementById('goalProgress').textContent = `${metrics.goalProgress.toFixed(1)}%`;
            
        }, 10000); // Update every 10 seconds
    }
}

// Additional CSS to add to your styles.css file
const additionalCSS = `
/* Performance Matrix Styles */
.performance-table-container {
    overflow-x: auto;
    border-radius: 10px;
    background: var(--darker-bg);
}

.performance-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
}

.performance-table th {
    background: var(--primary-color);
    color: white;
    padding: 15px 12px;
    text-align: left;
    font-weight: 600;
    white-space: nowrap;
}

.performance-table td {
    padding: 12px;
    border-bottom: 1px solid var(--border-color);
    white-space: nowrap;
}

.performance-table tr:hover {
    background: rgba(102, 126, 234, 0.1);
}

.performance-badge {
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
}

.badge-success {
    background: rgba(81, 207, 102, 0.2);
    color: var(--success-color);
}

.badge-warning {
    background: rgba(255, 212, 59, 0.2);
    color: var(--warning-color);
}

.badge-error {
    background: rgba(255, 107, 107, 0.2);
    color: var(--error-color);
}

/* Insights Styles */
.insight-item {
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
    border-left: 4px solid;
}

.insight-success {
    background: rgba(81, 207, 102, 0.1);
    border-color: var(--success-color);
}

.insight-info {
    background: rgba(116, 192, 252, 0.1);
    border-color: var(--info-color);
}

.insight-warning {
    background: rgba(255, 212, 59, 0.1);
    border-color: var(--warning-color);
}

.insight-item h5 {
    margin-bottom: 8px;
    font-size: 14px;
    font-weight: 600;
}

.insight-item p {
    font-size: 13px;
    line-height: 1.4;
    margin: 0;
}

/* Recommendations Styles */
.recommendation-section {
    background: var(--darker-bg);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
}

.recommendation-section h4 {
    color: var(--text-primary);
    margin-bottom: 15px;
    font-size: 16px;
}

.recommendation-section ul {
    list-style: none;
    padding: 0;
}

.recommendation-section li {
    padding: 8px 0;
    padding-left: 20px;
    position: relative;
    font-size: 14px;
    line-height: 1.4;
}

.recommendation-section li::before {
    content: "â¢";
    color: var(--primary-color);
    font-weight: bold;
    position: absolute;
    left: 0;
}

/* Error and No Results Styles */
.error-message {
    background: rgba(255, 107, 107, 0.1);
    border: 1px solid var(--error-color);
    color: var(--error-color);
    padding: 20px;
    border-radius: 8px;
    text-align: center;
}

.no-results {
    background: var(--darker-bg);
    padding: 40px;
    text-align: center;
    color: var(--text-secondary);
    border-radius: 8px;
}

/* Query Button Active State */
.query-btn.active {
    background: var(--primary-color);
    border-color: var(--primary-color);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
}

/* Responsive Improvements */
@media (max-width: 768px) {
    .performance-table {
        font-size: 12px;
    }
    
    .performance-table th,
    .performance-table td {
        padding: 8px 6px;
    }
    
    .recommendation-section {
        padding: 15px;
    }
    
    .insight-item {
        padding: 12px;
    }
}
`;

// Initialize the application when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.bostonBeatsApp = new BostonBeatsApp();
    
    // Optional: Enable real-time updates for demo
    // window.bostonBeatsApp.simulateRealTimeUpdates();
    
    console.log('Boston Beats Campaign Analytics loaded successfully!');
});

// Export for potential module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { BostonBeatsApp, DataProcessor, SQLEngine, ChartManager };
}
